package com.project.chatconnectbackend.controller.v1;

import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import com.project.chatconnectbackend.model.User;
import com.project.chatconnectbackend.repository.UserRepository;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Pattern;

@Validated
@RestController // This means that this class is a Controller
@RequestMapping(path = "/api/v1") // This means URL's start with /api/v1 (after Application path)
public class ControllerV1 {
  @Autowired // This means to get the bean called userRepository
  // Which is auto-generated by Spring, we will use it to handle the data
  private UserRepository userRepository;

  @PostMapping(path = "/register", produces = "application/json") // Map ONLY POST Requests
  public @ResponseBody ResponseEntity<Map<String, Object>> registerNewUser(
      @Valid @RequestParam String name,
      @Valid @Pattern(regexp = "\\d{10}", message = "Phone number must be a 10-digit string") @RequestParam String phone,
      @Valid @RequestParam String password) {
    try {
      // @ResponseBody means the returned String is the response, not a view name
      // @RequestParam means it is a parameter from the GET or POST request
      User newUser = new User();
      // Split name by space
      String[] nameParts = name.split(" ");
      String[] avatarUrls = new String[]{
        "https://github.com/amanlajpal/chat-connect/blob/aman/chat-connect-backend/src/main/resources/static/assets/images/BlueJay.png?raw=true",
        "https://github.com/amanlajpal/chat-connect/blob/aman/chat-connect-backend/src/main/resources/static/assets/images/Eagle.png?raw=true",
        "https://github.com/amanlajpal/chat-connect/blob/aman/chat-connect-backend/src/main/resources/static/assets/images/GreenParrot.png?raw=true",
        "https://github.com/amanlajpal/chat-connect/blob/aman/chat-connect-backend/src/main/resources/static/assets/images/Peacock.png?raw=true",
        "https://github.com/amanlajpal/chat-connect/blob/aman/chat-connect-backend/src/main/resources/static/assets/images/RedParrot.png?raw=true",
      };

      // Check if name has only one part (no spaces)
      String firstName;
      String lastName;
      if (nameParts.length == 1) {
        firstName = nameParts[0].trim(); // Use entire name as first name
        lastName = ""; // Set last name to empty string
      } else {
        // Use first part as first name and remaining parts as last name
        firstName = nameParts[0].trim();
        lastName = name.substring(name.indexOf(" ") + 1).trim();
      }
      newUser.setFirst_name(firstName);
      newUser.setLast_name(lastName);
      newUser.setPhone_number(phone);
      newUser.setPassword(password);
      newUser.setProfile_photo(avatarUrls[(int) (Math.random() * avatarUrls.length)]);
      userRepository.save(newUser);

      // Create the response body
      Map<String, Object> responseBody = new HashMap<>();
      responseBody.put("status", "success");
      responseBody.put("data", newUser);
      responseBody.put("message", "User Saved");

      return ResponseEntity.ok(responseBody);
    } catch (DataIntegrityViolationException e) {
      // Handle unique constraint violation (e.g., duplicate phone number or email)
      Map<String, Object> errorResponseBody = new HashMap<>();
      errorResponseBody.put("status", "error");
      errorResponseBody.put("message", "User with the provided phone number or email already exists");
      return ResponseEntity.status(HttpStatus.CONFLICT).body(errorResponseBody);
    } catch (EmptyResultDataAccessException e) {
      // Handle case where no user is found
      Map<String, Object> errorResponseBody = new HashMap<>();
      errorResponseBody.put("status", "error");
      errorResponseBody.put("message", "User not found" + e.getMessage());
      return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponseBody);
    } catch (Exception e) {
      // Return an error response if an exception occurs
      Map<String, Object> errorResponseBody = new HashMap<>();
      errorResponseBody.put("status", "error");
      errorResponseBody.put("message", "An error occurred: " + e.getMessage());
      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponseBody);
    }
  }

  @PostMapping(path = "/login", produces = "application/json") // Map ONLY POST Requests
  public @ResponseBody ResponseEntity<Map<String, Object>> loginUser(
      @Valid @Pattern(regexp = "\\d{10}", message = "Phone number must be a 10-digit string") @RequestParam String phone,
      @Valid @RequestParam String password) {
    try {

      User user = userRepository.findByPhoneAndPassword(phone, password);

      if (user == null) {
        // Handle case where no user is found
        Map<String, Object> errorResponseBody = new HashMap<>();
        errorResponseBody.put("status", "error");
        errorResponseBody.put("message", "User not found");
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponseBody);
      }

      // Create the response body
      Map<String, Object> responseBody = new HashMap<>();
      responseBody.put("status", "success");
      responseBody.put("data", user);
      responseBody.put("message", "Logged in successfully");

      return ResponseEntity.ok(responseBody);
    } catch (DataIntegrityViolationException e) {
      // Handle unique constraint violation (e.g., duplicate phone number or email)
      Map<String, Object> errorResponseBody = new HashMap<>();
      errorResponseBody.put("status", "error");
      errorResponseBody.put("message", "User with the provided phone number or email already exists");
      return ResponseEntity.status(HttpStatus.CONFLICT).body(errorResponseBody);
    } catch (EmptyResultDataAccessException e) {
      // Handle case where no user is found
      Map<String, Object> errorResponseBody = new HashMap<>();
      errorResponseBody.put("status", "error");
      errorResponseBody.put("message", "User not found" + e.getMessage());
      return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponseBody);
    } catch (Exception e) {
      // Return an error response if an exception occurs
      Map<String, Object> errorResponseBody = new HashMap<>();
      errorResponseBody.put("status", "error");
      errorResponseBody.put("message", "An error occurred: " + e.getMessage());
      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponseBody);
    }
  }

  @GetMapping(path = "/allChats", produces = "application/json") // Map ONLY GET Requests
  public @ResponseBody ResponseEntity<Map<String, Object>> getAllUsers() {
    try {
      // This returns a JSON or XML with the users
      // Create the response body
      Iterable<User> users = userRepository.findAll();
      Map<String, Object> responseBody = new HashMap<>();
      responseBody.put("status", "success");
      responseBody.put("data", users);
      responseBody.put("message", "Users fetched successfully!");

      return ResponseEntity.ok(responseBody);
    } catch (DataIntegrityViolationException e) {
      // Handle unique constraint violation (e.g., duplicate phone number or email)
      Map<String, Object> errorResponseBody = new HashMap<>();
      errorResponseBody.put("status", "error");
      errorResponseBody.put("message", "User with the provided phone number or email already exists");
      return ResponseEntity.status(HttpStatus.CONFLICT).body(errorResponseBody);
    } catch (EmptyResultDataAccessException e) {
      // Handle case where no user is found
      Map<String, Object> errorResponseBody = new HashMap<>();
      errorResponseBody.put("status", "error");
      errorResponseBody.put("message", "User not found" + e.getMessage());
      return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponseBody);
    } catch (Exception e) {
      // Return an error response if an exception occurs
      Map<String, Object> errorResponseBody = new HashMap<>();
      errorResponseBody.put("status", "error");
      errorResponseBody.put("message", "An error occurred: " + e.getMessage());
      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponseBody);
    }
  }
}