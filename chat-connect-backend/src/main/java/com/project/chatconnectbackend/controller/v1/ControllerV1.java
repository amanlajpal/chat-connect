package com.project.chatconnectbackend.controller.v1;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import com.project.chatconnectbackend.chat.Chat;
import com.project.chatconnectbackend.model.Conversation;
import com.project.chatconnectbackend.model.GroupMember;
import com.project.chatconnectbackend.model.Message;
import com.project.chatconnectbackend.model.User;
import com.project.chatconnectbackend.repository.ConversationRepository;
import com.project.chatconnectbackend.repository.GroupMemberRepository;
import com.project.chatconnectbackend.repository.MessageRepository;
import com.project.chatconnectbackend.repository.UserRepository;
import com.project.chatconnectbackend.utility.Response;

import jakarta.transaction.Transactional;
// import jakarta.persistence.PersistenceException;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Pattern;

@Validated
@RestController // This means that this class is a Controller
@RequestMapping(path = "/api/v1") // This means URL's start with /api/v1 (after Application path)
public class ControllerV1 {
  @Autowired // This means to get the bean called userRepository
  // Which is auto-generated by Spring, we will use it to handle the data
  private UserRepository userRepository;

  @Autowired // This means to get the bean called conversationRepository
  // Which is auto-generated by Spring, we will use it to handle the data
  private ConversationRepository conversationRepository;

  @Autowired // This means to get the bean called messageRepository
  // Which is auto-generated by Spring, we will use it to handle the data
  private MessageRepository messageRepository;

  @Autowired // This means to get the bean called groupMemberRepository
  // Which is auto-generated by Spring, we will use it to handle the data
  private GroupMemberRepository groupMemberRepository;

  @PostMapping(path = "/register", produces = "application/json") // Map ONLY POST Requests
  public @ResponseBody ResponseEntity<Map<String, Object>> registerNewUser(
      @Valid @RequestParam String name,
      @Valid @Pattern(regexp = "\\d{10}", message = "Phone number must be a 10-digit string") @RequestParam String phone,
      @Valid @RequestParam String password) {
    try {
      // @ResponseBody means the returned String is the response, not a view name
      // @RequestParam means it is a parameter from the GET or POST request
      User newUser = new User();
      // Split name by space
      String[] nameParts = name.split(" ");
      String[] avatarUrls = new String[] {
          "https://img.freepik.com/free-psd/3d-illustration-person_23-2149436192.jpg",
          "https://img.freepik.com/free-photo/3d-render-little-boy-with-eyeglasses-blue-shirt_1142-50994.jpg",
          "https://img.freepik.com/free-photo/portrait-boy-blue-cap-glasses-3d-rendering_1142-40451.jpg",
          "https://img.freepik.com/free-photo/3d-cartoon-style-character_23-2151034077.jpg",
          "https://img.freepik.com/premium-photo/happy-3d-cartoon-man-using-laptop-siting-transparent-white-background_973886-19.jpg"
      };

      // Check if name has only one part (no spaces)
      String firstName;
      String lastName;
      if (nameParts.length == 1) {
        firstName = nameParts[0].trim(); // Use entire name as first name
        lastName = ""; // Set last name to empty string
      } else {
        // Use first part as first name and remaining parts as last name
        firstName = nameParts[0].trim();
        lastName = name.substring(name.indexOf(" ") + 1).trim();
      }
      newUser.setFirstName(firstName);
      newUser.setLastName(lastName);
      newUser.setPhoneNumber(phone);
      newUser.setPassword(password);
      newUser.setProfilePhoto(avatarUrls[(int) (Math.random() * avatarUrls.length)]);
      User createdUser = userRepository.save(newUser);
      newUser.setId(createdUser.getId());

      // Create the response body
      Map<String, Object> responseBody = new HashMap<>();
      responseBody.put("status", "success");
      responseBody.put("data", newUser);
      responseBody.put("message", "User Saved");

      return ResponseEntity.ok(responseBody);
    } finally {
      System.out.println("User saved");
    }
  }

  @PostMapping(path = "/login", produces = "application/json") // Map ONLY POST Requests
  public @ResponseBody ResponseEntity<Map<String, Object>> loginUser(
      @Valid @Pattern(regexp = "\\d{10}", message = "Phone number must be a 10-digit string") @RequestParam String phone,
      @Valid @RequestParam String password) {
    try {

      User user = userRepository.findByPhoneNumberAndPassword(phone, password);

      if (user == null) {
        // Handle case where no user is found
        Map<String, Object> errorResponseBody = new HashMap<>();
        errorResponseBody.put("status", "error");
        errorResponseBody.put("message", "User not found");
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponseBody);
      }

      // Create the response body
      Map<String, Object> responseBody = new HashMap<>();
      responseBody.put("status", "success");
      responseBody.put("data", user);
      responseBody.put("message", "Logged in successfully");

      return ResponseEntity.ok(responseBody);
    } catch (DataIntegrityViolationException e) {
      // Handle unique constraint violation (e.g., duplicate phone number or email)
      Map<String, Object> errorResponseBody = new HashMap<>();
      errorResponseBody.put("status", "error");
      errorResponseBody.put("message", "User with the provided phone number or email already exists");
      return ResponseEntity.status(HttpStatus.CONFLICT).body(errorResponseBody);
    } catch (EmptyResultDataAccessException e) {
      // Handle case where no user is found
      Map<String, Object> errorResponseBody = new HashMap<>();
      errorResponseBody.put("status", "error");
      errorResponseBody.put("message", "User not found" + e.getMessage());
      return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponseBody);
    } catch (Exception e) {
      // Return an error response if an exception occurs
      Map<String, Object> errorResponseBody = new HashMap<>();
      errorResponseBody.put("status", "error");
      errorResponseBody.put("message", "An error occurred: " + e.getMessage());
      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponseBody);
    }
  }

  @GetMapping(path = "/allChats", produces = "application/json") // Map ONLY GET Requests
  public @ResponseBody ResponseEntity<Map<String, Object>> getAllUsers() {
    try {
      // This returns a JSON or XML with the users
      // Create the response body
      Iterable<User> users = userRepository.findAll();
      ArrayList<Chat> chats = new ArrayList<>();
      users.forEach(user -> {
        user.setPassword(null);
        chats.add(Chat.builder()
            .phoneNumber(user.getPhoneNumber())
            .name(user.getFirstName() + " " + user.getLastName())
            .profilePhoto(user.getProfilePhoto())
            .status(null)
            .lastMessage(null)
            .lastMessageTime(null)
            .id(user.getId())
            .build());
      });
      Map<String, Object> responseBody = new HashMap<>();
      responseBody.put("status", "success");
      responseBody.put("data", chats);
      responseBody.put("message", "Users fetched successfully!");

      return ResponseEntity.ok(responseBody);
    } finally {
      System.out.println("Users fetched");
    }
  }

  @GetMapping(path = "/users/messages", produces = "application/json") // Map ONLY GET Requests
  @Transactional
  public @ResponseBody ResponseEntity<Map<String, Object>> getUserMessages(
      @RequestParam String userId1, String userId2) {
    try {
      // Create the response body
      Integer[] userIdsForMessages = new Integer[] { Integer.parseInt(userId1), Integer.parseInt(userId2) };
      List<Map<String, Object>> foundConversations = conversationRepository
          .findDirectConversationBetweenUsers("direct", userIdsForMessages);
      Integer foundConversationId = foundConversations.size() > 0
          ? (Integer) ((Map<String, Object>) foundConversations.get(0)).get("conversation_id")
          : null;
      if (foundConversationId != null) {
        List<Message> foundMessages = messageRepository.findMessagesByConversationId(foundConversationId);
        if (foundMessages.isEmpty()) {
          return new Response().error(foundMessages, "No messages found between users", 422);
        } else {
          return new Response().success(foundMessages, "Messages fetched successfully!");
        }
      } else {
        Conversation newConversation = new Conversation();
        newConversation.setConversationName("direct");
        Conversation createdConversation = conversationRepository.save(newConversation);
        Set<GroupMember> createdGroupMembers = new HashSet<>();
        for (Integer userId : userIdsForMessages) {
          GroupMember groupMember = new GroupMember();
          groupMember.setConversation(createdConversation);
          Optional<User> user = userRepository.findById(Objects.requireNonNull(userId));
          if (user.isPresent()) {
            groupMember.setUsers(user.get()); // Fix: Pass the actual User object instead of Optional<User>
          }
          GroupMember createdGroupMember = groupMemberRepository.save(groupMember);
          createdGroupMembers.add(createdGroupMember);
        }
      }
      // Get messages between two users
      return new Response().success(foundConversationId, "Messages fetched successfully!");
    } finally {
      System.out.println("Messages fetched");
    }
  }
}